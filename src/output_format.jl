"""
Output Format Management for Heat3ds Parareal Integration

This module ensures that parareal computations generate output in the same format
as sequential Heat3ds computations, satisfying Requirement 3.4.

Key features:
- Identical output file formats between parareal and sequential modes
- Parareal-specific metadata addition without breaking compatibility
- Visualization compatibility maintenance
"""

module OutputFormat

using Printf
using Dates

export OutputManager, create_output_manager, generate_parareal_output!, ensure_output_consistency!

"""
Configuration for output generation
"""
struct OutputConfig
    base_filename::String
    computation_mode::String  # "sequential" or "parareal"
    include_metadata::Bool
    maintain_compatibility::Bool
end

"""
Metadata about the parareal computation
"""
struct OutputMetadata
    timestamp::DateTime
    grid_size::Tuple{Int,Int,Int}
    n_time_windows::Int
    n_mpi_processes::Int
    parareal_iterations::Int
    convergence_achieved::Bool
    computation_time::Float64
end

"""
OutputManager manages the generation of Heat3ds-compatible output files
for parareal computations.
"""
struct OutputManager
    config::OutputConfig
    metadata::OutputMetadata
    file_registry::Vector{String}
end

"""
Create an OutputManager for Heat3ds-compatible output generation.

# Arguments
- `base_filename`: Base name for output files
- `computation_mode`: "sequential" or "parareal"
- `grid_size`: Grid dimensions (NX, NY, NZ)
- `n_time_windows`: Number of time windows (parareal only)
- `n_mpi_processes`: Number of MPI processes (parareal only)

# Returns
- `OutputManager`: Configured output manager
"""
function create_output_manager(;
    base_filename::String = "heat3ds",
    computation_mode::String = "sequential",
    grid_size::Tuple{Int,Int,Int} = (0, 0, 0),
    n_time_windows::Int = 1,
    n_mpi_processes::Int = 1,
    include_metadata::Bool = true,
    maintain_compatibility::Bool = true
)
    
    config = OutputConfig(
        base_filename,
        computation_mode,
        include_metadata,
        maintain_compatibility
    )
    
    metadata = OutputMetadata(
        now(),
        grid_size,
        n_time_windows,
        n_mpi_processes,
        0,  # Will be updated later
        false,  # Will be updated later
        0.0  # Will be updated later
    )
    
    return OutputManager(config, metadata, String[])
end

"""
Generate parareal output files in Heat3ds-compatible format.

This function ensures that all output files generated by parareal computations
are identical in format to those generated by sequential Heat3ds runs.

# Arguments
- `manager`: OutputManager instance
- `temperature_field`: Final temperature distribution
- `result`: Parareal computation result
- `problem_data`: Heat3ds problem data

# Returns
- `Vector{String}`: List of generated output files
"""
function generate_parareal_output!(
    manager::OutputManager,
    temperature_field::Array{Float64,3},
    result,
    problem_data
)
    generated_files = String[]
    
    try
        # Update metadata with actual computation results
        updated_metadata = OutputMetadata(
            manager.metadata.timestamp,
            manager.metadata.grid_size,
            manager.metadata.n_time_windows,
            manager.metadata.n_mpi_processes,
            get(result, :iterations, 0),
            get(result, :converged, false),
            get(result, :computation_time, 0.0)
        )
        
        # Generate temperature data files in Heat3ds format
        temp_files = generate_temperature_output(manager, temperature_field, updated_metadata)
        append!(generated_files, temp_files)
        
        # Generate convergence data files (if applicable)
        if haskey(result, :residual_history) && !isempty(get(result, :residual_history, []))
            conv_files = generate_convergence_output(manager, result, updated_metadata)
            append!(generated_files, conv_files)
        end
        
        # Generate metadata file (parareal-specific, but optional)
        if manager.config.include_metadata && manager.config.computation_mode == "parareal"
            metadata_file = generate_metadata_output(manager, updated_metadata)
            push!(generated_files, metadata_file)
        end
        
        # Update file registry
        append!(manager.file_registry, generated_files)
        
        return generated_files
        
    catch e
        @error "Failed to generate parareal output: $e"
        return String[]
    end
end

"""
Generate temperature field output files in Heat3ds-compatible format.
"""
function generate_temperature_output(
    manager::OutputManager,
    temperature_field::Array{Float64,3},
    metadata::OutputMetadata
)
    generated_files = String[]
    
    try
        # Generate binary temperature data file (Heat3ds standard format)
        temp_filename = "$(manager.config.base_filename)_temperature.dat"
        
        open(temp_filename, "w") do f
            # Write header in Heat3ds format
            write(f, Int32(metadata.grid_size[1]))  # NX
            write(f, Int32(metadata.grid_size[2]))  # NY  
            write(f, Int32(metadata.grid_size[3]))  # NZ
            write(f, Float64(metadata.timestamp.instant.periods.value))  # Timestamp
            
            # Write temperature data in Heat3ds binary format
            write(f, temperature_field)
        end
        
        push!(generated_files, temp_filename)
        
        # Generate CSV temperature data file (for compatibility)
        csv_filename = "$(manager.config.base_filename)_temperature.csv"
        
        open(csv_filename, "w") do f
            # Write CSV header
            println(f, "# Heat3ds Temperature Data")
            println(f, "# Grid: $(metadata.grid_size[1])x$(metadata.grid_size[2])x$(metadata.grid_size[3])")
            println(f, "# Computation mode: $(manager.config.computation_mode)")
            if manager.config.computation_mode == "parareal"
                println(f, "# Time windows: $(metadata.n_time_windows)")
                println(f, "# MPI processes: $(metadata.n_mpi_processes)")
            end
            println(f, "# Generated: $(metadata.timestamp)")
            println(f, "i,j,k,temperature")
            
            # Write temperature data
            for k in 1:size(temperature_field, 3)
                for j in 1:size(temperature_field, 2)
                    for i in 1:size(temperature_field, 1)
                        println(f, "$i,$j,$k,$(temperature_field[i,j,k])")
                    end
                end
            end
        end
        
        push!(generated_files, csv_filename)
        
        return generated_files
        
    catch e
        @error "Failed to generate temperature output: $e"
        return String[]
    end
end

"""
Generate convergence data output files in Heat3ds-compatible format.
"""
function generate_convergence_output(
    manager::OutputManager,
    result,
    metadata::OutputMetadata
)
    generated_files = String[]
    
    try
        # Generate convergence CSV file (Heat3ds standard format)
        conv_filename = "$(manager.config.base_filename)_convergence.csv"
        
        open(conv_filename, "w") do f
            # Write header in Heat3ds format
            println(f, "# Heat3ds Convergence Data")
            println(f, "# Grid: $(metadata.grid_size[1])x$(metadata.grid_size[2])x$(metadata.grid_size[3])")
            println(f, "# Computation mode: $(manager.config.computation_mode)")
            if manager.config.computation_mode == "parareal"
                println(f, "# Parareal iterations: $(metadata.parareal_iterations)")
                println(f, "# Time windows: $(metadata.n_time_windows)")
            end
            println(f, "# Generated: $(metadata.timestamp)")
            println(f, "iteration,residual")
            
            # Write convergence data
            residual_history = get(result, :residual_history, Float64[])
            if !isempty(residual_history)
                for (i, residual) in enumerate(residual_history)
                    println(f, "$i,$residual")
                end
            else
                # Write placeholder if no convergence data
                println(f, "1,0.0")
            end
        end
        
        push!(generated_files, conv_filename)
        
        return generated_files
        
    catch e
        @error "Failed to generate convergence output: $e"
        return String[]
    end
end

"""
Generate parareal-specific metadata file (optional, for enhanced functionality).
"""
function generate_metadata_output(
    manager::OutputManager,
    metadata::OutputMetadata
)
    metadata_filename = "$(manager.config.base_filename)_parareal_metadata.json"
    
    try
        open(metadata_filename, "w") do f
            # Write JSON metadata
            println(f, "{")
            println(f, "  \"computation_mode\": \"$(manager.config.computation_mode)\",")
            println(f, "  \"timestamp\": \"$(metadata.timestamp)\",")
            println(f, "  \"grid_size\": [$(metadata.grid_size[1]), $(metadata.grid_size[2]), $(metadata.grid_size[3])],")
            println(f, "  \"n_time_windows\": $(metadata.n_time_windows),")
            println(f, "  \"n_mpi_processes\": $(metadata.n_mpi_processes),")
            println(f, "  \"parareal_iterations\": $(metadata.parareal_iterations),")
            println(f, "  \"convergence_achieved\": $(metadata.convergence_achieved),")
            println(f, "  \"computation_time\": $(metadata.computation_time),")
            println(f, "  \"heat3ds_compatible\": true")
            println(f, "}")
        end
        
        return metadata_filename
        
    catch e
        @error "Failed to generate metadata output: $e"
        return ""
    end
end

"""
Ensure output consistency between parareal and sequential modes.

This function validates that parareal-generated output files are compatible
with Heat3ds sequential output format.

# Arguments
- `manager`: OutputManager instance

# Returns
- `Bool`: true if output is consistent, false otherwise
"""
function ensure_output_consistency!(manager::OutputManager)
    try
        # Check that all required files were generated
        required_files = [
            "$(manager.config.base_filename)_temperature.dat",
            "$(manager.config.base_filename)_temperature.csv"
        ]
        
        for file in required_files
            if !isfile(file)
                @warn "Required output file missing: $file"
                return false
            end
        end
        
        # Validate file formats
        if !validate_temperature_format(manager)
            @warn "Temperature file format validation failed"
            return false
        end
        
        # Check file sizes are reasonable
        if !validate_file_sizes(manager)
            @warn "Output file size validation failed"
            return false
        end
        
        return true
        
    catch e
        @error "Output consistency check failed: $e"
        return false
    end
end

"""
Validate temperature file format consistency.
"""
function validate_temperature_format(manager::OutputManager)
    try
        temp_dat_file = "$(manager.config.base_filename)_temperature.dat"
        temp_csv_file = "$(manager.config.base_filename)_temperature.csv"
        
        # Check binary file format
        if isfile(temp_dat_file)
            filesize_dat = filesize(temp_dat_file)
            expected_header_size = 4 * 3 + 8  # 3 Int32 + 1 Float64
            
            if filesize_dat < expected_header_size
                @warn "Binary temperature file too small: $filesize_dat bytes"
                return false
            end
        end
        
        # Check CSV file format
        if isfile(temp_csv_file)
            lines = readlines(temp_csv_file)
            if length(lines) < 10  # Should have header + data
                @warn "CSV temperature file too small: $(length(lines)) lines"
                return false
            end
            
            # Check header format
            if !startswith(lines[1], "# Heat3ds Temperature Data")
                @warn "CSV temperature file missing proper header"
                return false
            end
        end
        
        return true
        
    catch e
        @error "Temperature format validation failed: $e"
        return false
    end
end

"""
Validate output file sizes are reasonable.
"""
function validate_file_sizes(manager::OutputManager)
    try
        for file in manager.file_registry
            if isfile(file)
                size_bytes = filesize(file)
                if size_bytes == 0
                    @warn "Output file is empty: $file"
                    return false
                end
                
                # Check for unreasonably large files (> 1GB)
                if size_bytes > 1_000_000_000
                    @warn "Output file suspiciously large: $file ($(size_bytes) bytes)"
                    return false
                end
            end
        end
        
        return true
        
    catch e
        @error "File size validation failed: $e"
        return false
    end
end

end # module OutputFormat